package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"net/http"
	"os/exec"
	"regexp"

	"github.com/buger/jsonparser"
	log "github.com/sirupsen/logrus"
)

func command(s string) error {
	out, err := exec.Command("bash", "-c", s).CombinedOutput()
	outString := string(out)

	log.Debug(s)
	log.Info(outString)

	if err != nil {
		return err
	}
	return nil
}

// absent checks whether a specific docker image is absent
// in a given docker registry. If true, then a certain docker
// image is absent in a certain docker registry
func absent(image, registry string) bool {
	cmd := "docker pull " + registry + image
	out, err := exec.Command("bash", "-c", cmd).CombinedOutput()
	outString := string(out)

	log.WithFields(log.Fields{
		"cmd":      cmd,
		"output":   outString,
		"image":    image,
		"registry": registry,
	}).Debug("Whether an image is absent in a registry")

	if err != nil {
		if exitError, ok := err.(*exec.ExitError); ok {
			exitError.ExitCode()
			log.Debug(exitError.ExitCode())
			return true
		}
	}

	return false
}

//todo
//todo
//todo

// latest is able to get the latest tag of an image
func latest(image string) *http.Response {
	//selenium/standalone-chrome
	// should return 3.141.59
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	resp, err := http.Get("https://registry.hub.docker.com/v2/repositories/library/" + image + "/tags?page_size=1024")
	// resp, err := http.Get("https://registry.hub.docker.com/v2/repositories/library/nginx/tags?page_size=1024")
	// resp, err := http.Get("https://registry.hub.docker.com/v2/repositories/selenium/standalone-chrome-debug/tags?page_size=1024")
	if err != nil {
		log.Fatal(err)
	}

	return resp
}

func readResp(resp *http.Response) []byte {
	defer resp.Body.Close()
	// var bodyString string
	var b []byte
	var err error
	if resp.StatusCode == http.StatusOK {
		b, err = ioutil.ReadAll(resp.Body)
		if err != nil {
			log.Fatal(err)
		}
		// bodyString = string(bodyBytes)
		// log.Info(bodyString)

	}
	// return bodyString
	return b
}

func latestTag(b []byte, t string) []string {
	var c string
	var arr []string
	jsonparser.ArrayEach(b, func(value []byte, dataType jsonparser.ValueType, offset int, err error) {
		s, _ := jsonparser.GetString(value, "name")
		// fmt.Println(s)

		a := fmt.Sprintf(`%s`, t)
		// re := regexp.MustCompile(`.*\d-alpine$`)
		re := regexp.MustCompile(a)
		if re.FindString(s) != "" {
			c = fmt.Sprintf("%v", re.FindString(s))
			fmt.Println(c)
			arr = append(arr, c)
		}
		//  else {
		// 	fmt.Println("no match")
		// }
	}, "results")

	return arr
}

func main() {
	debug := flag.Bool("debug", false, "Whether debug mode should be enabled")
	image := flag.String("image", "", "The origin of the image, e.g. nginx:1.17.5-alpine")
	tagType := flag.String("tagType", "xenial", "The tag type, e.g. xenial")
	// registry := flag.String("registry", "", "To what destination the image should be transferred, e.g. quay.io/some-org/. Note: do not omit the last forward slash.")
	// preserve := flag.Bool("preserve", false, "Whether an image should be preserved in another registry.")

	flag.Parse()

	if *debug {
		log.SetLevel(log.DebugLevel)
	}

	// dockerImageAbsent := absent(*image, *registry)

	// if !dockerImageAbsent {
	// 	log.Fatal("Docker image: ", *image, " already exists in registry: ", *registry)
	// } else {
	// 	log.Info("Docker image: ", *image, " does NOT exist in registry: ", *registry)
	// }

	// if *preserve {
	log.Info("preserve")
	fmt.Println(latestTag(readResp(latest(*image)), *tagType))
	// } else {
	// log.Info("do not preserve")
	// }
}
